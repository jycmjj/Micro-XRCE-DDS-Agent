From a3676ff82e5cd69a5d4631f2f6163dbeda371ba2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E8=82=96=E7=BE=8E=E7=A5=A5240108?= <2922073250@xiaomi.com>
Date: Fri, 7 Jun 2024 16:30:55 +0800
Subject: [PATCH] tijiao

---
 Student.h                                     |  10 +
 data1.c                                       |  75 +++++++
 data1.h                                       |  58 +++++
 microxrce_agent.cpp                           | 211 +++++++++++++++++-
 .../middleware/fastdds/FastDDSMiddleware.cpp  |   1 +
 studentdata.c                                 |  75 +++++++
 studentdata.h                                 |  58 +++++
 7 files changed, 484 insertions(+), 4 deletions(-)
 create mode 100644 Student.h
 create mode 100644 data1.c
 create mode 100644 data1.h
 create mode 100644 studentdata.c
 create mode 100644 studentdata.h

diff --git a/Student.h b/Student.h
new file mode 100644
index 0000000..4173328
--- /dev/null
+++ b/Student.h
@@ -0,0 +1,10 @@
+#pragma once
+#include <string>
+#include <array>
+
+struct Student {
+    std::string name;
+    long number;
+    long grade;
+    std::array<std::string, 3> hobby;
+};
diff --git a/data1.c b/data1.c
new file mode 100644
index 0000000..f683cc5
--- /dev/null
+++ b/data1.c
@@ -0,0 +1,75 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file data1.c
+ * This source file contains the definition of the described types in the IDL file.
+ *
+ * This file was generated by the tool gen.
+ */
+
+#include "data1.h"
+
+#include <ucdr/microcdr.h>
+#include <string.h>
+
+bool Student_serialize_topic(ucdrBuffer* writer, const Student* topic)
+{
+    bool success = true;
+
+        success &= ucdr_serialize_string(writer, topic->name);
+
+        success &= ucdr_serialize_int32_t(writer, topic->number);
+
+        success &= ucdr_serialize_int32_t(writer, topic->grade);
+
+        for(size_t i = 0; i < sizeof(topic->hobby) / 255; ++i)
+        {
+            success &= ucdr_serialize_string(writer, topic->hobby[i]);
+        }
+    return success && !writer->error;
+}
+
+bool Student_deserialize_topic(ucdrBuffer* reader, Student* topic)
+{
+    bool success = true;
+
+        success &= ucdr_deserialize_string(reader, topic->name, 255);
+
+        success &= ucdr_deserialize_int32_t(reader, &topic->number);
+
+        success &= ucdr_deserialize_int32_t(reader, &topic->grade);
+
+        for(size_t i = 0; i < sizeof(topic->hobby) / 255; ++i)
+        {
+            success &= ucdr_deserialize_string(reader, topic->hobby[i], 255);
+        }
+    return success && !reader->error;
+}
+
+uint32_t Student_size_of_topic(const Student* topic, uint32_t size)
+{
+    uint32_t previousSize = size;
+        size += ucdr_alignment(size, 4) + 4 + (uint32_t)strlen(topic->name) + 1;
+
+        size += ucdr_alignment(size, 4) + 4;
+
+        size += ucdr_alignment(size, 4) + 4;
+
+        for(size_t i = 0; i < sizeof(topic->hobby) / 255; ++i)
+        {
+            size += ucdr_alignment(size, 4) + 4 + (uint32_t)strlen(topic->hobby[i]) + 1;
+        }
+    return size - previousSize;
+}
diff --git a/data1.h b/data1.h
new file mode 100644
index 0000000..d824d9b
--- /dev/null
+++ b/data1.h
@@ -0,0 +1,58 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file data1.h
+ * This header file contains the declaration of the described types in the IDL file.
+ *
+ * This file was generated by the tool gen.
+ */
+
+#ifndef _data1_H_
+#define _data1_H_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/*!
+ * @brief This struct represents the structure Student defined by the user in the IDL file.
+ * @ingroup data1
+ */
+typedef struct Student
+{
+    char name[255];
+
+    int32_t number;
+    int32_t grade;
+    char hobby[3][255];
+
+} Student;
+
+struct ucdrBuffer;
+
+bool Student_serialize_topic(struct ucdrBuffer* writer, const Student* topic);
+bool Student_deserialize_topic(struct ucdrBuffer* reader, Student* topic);
+uint32_t Student_size_of_topic(const Student* topic, uint32_t size);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _data1_H_
\ No newline at end of file
diff --git a/microxrce_agent.cpp b/microxrce_agent.cpp
index e4fc766..aeae2d5 100644
--- a/microxrce_agent.cpp
+++ b/microxrce_agent.cpp
@@ -13,16 +13,219 @@
 // limitations under the License.
 
 #include <uxr/agent/AgentInstance.hpp>
+#include <iostream>
+#include <fstream>
+#include <vector>
+#include <algorithm>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <cstring>
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include "Student.h"
 
-int main(int argc, char** argv)
+#define PORT 2024
+using namespace std;
+struct AgentMesg
 {
-    eprosima::uxr::AgentInstance& agent_instance = agent_instance.getInstance();
+    int argcAgent;
+    char **argvAgent;
+};
 
-    if (!agent_instance.create(argc, argv))
+struct FileInfo {
+    string filename;
+    unsigned long long timestamp;
+};
+
+mutex mtx;
+condition_variable cv;
+vector<Student> students;
+bool saveFlag = false;
+bool done = false;
+
+bool compareStudents(const Student& s1, const Student& s2) {
+    if (s1.number != s2.number) {
+        return s1.number < s2.number;
+    } else if (s1.grade > s2.grade) {
+        return s2.number;
+    } else {
+        return s1.number;
+    }
+}
+
+string getCurrentTime() {
+    time_t now = time(0);
+    tm *ltm = localtime(&now);
+    char buf[80];
+    strftime(buf, sizeof(buf), "%Y%m%d%H%M%S", ltm);
+    return string(buf);
+}
+
+unsigned long long getCurrentTimestamp() {
+    return static_cast<unsigned long long>(time(0));
+}
+
+FileInfo saveToFile(const vector<Student>& students) {
+    string filename = "../file/" + getCurrentTime() + ".txt";
+    ofstream outfile(filename);
+    for (const auto& student : students) {
+        outfile << student.name << " " << student.number << " " << student.grade << " ";
+        for (int i = 0; i < 3; ++i) {
+            outfile << student.hobby[i] << " ";
+        }
+        outfile << endl;
+    }
+    outfile.close();
+
+    FileInfo fileInfo;
+    fileInfo.filename = filename;
+    fileInfo.timestamp = getCurrentTimestamp();
+    return fileInfo;
+}
+
+void fileSaver() {
+    while (true) {
+        vector<Student> local_students;
+        {
+            unique_lock<mutex> lock(mtx);
+            cv.wait(lock, [] { return saveFlag || done; });
+            if (done && students.empty()) {
+                break;
+            }
+            if (saveFlag) {
+                local_students.swap(students);
+                saveFlag = false;
+            }
+        }
+        if (!local_students.empty()) {
+            sort(local_students.begin(), local_students.end(), compareStudents);
+            saveToFile(local_students);
+        }
+    }
+}
+
+Student deserializeStudent(const char* buffer) { // 反序列化
+    Student student;
+    char name[50], hobby1[30], hobby2[30], hobby3[30];
+    int fields = sscanf(buffer, "%29[^,],%ld,%ld,%29[^,],%29[^,],%29[^,]", name, &student.number, &student.grade, hobby1, hobby2, hobby3);
+    student.name = string(name);
+    student.hobby[0] = hobby1;
+    student.hobby[1] = hobby2;
+    student.hobby[2] = hobby3;
+    return student;
+}
+
+void receiveData() {
+    int server_fd, new_socket;
+    struct sockaddr_in address;
+    int opt = 1;
+    int addrlen = sizeof(address);
+    char buffer[256] = {0};
+
+    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
+        perror("socket 失败");
+        exit(EXIT_FAILURE);
+    }
+
+    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
+        perror("setsockopt 失败");
+        exit(EXIT_FAILURE);
+    }
+
+    address.sin_family = AF_INET;
+    address.sin_addr.s_addr = INADDR_ANY;
+    address.sin_port = htons(PORT);
+
+    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
+        perror("bind 错误");
+        exit(EXIT_FAILURE);
+    }
+
+    if (listen(server_fd, 3) < 0) {
+        perror("listen 错误");
+        exit(EXIT_FAILURE);
+    }
+
+    vector<thread> client_threads; 
+
+    while (true) {
+        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {
+            perror("accept 错误");
+            exit(EXIT_FAILURE);
+        }
+
+        // 创建一个新线程来处理每个客户端
+        client_threads.emplace_back([new_socket]() {
+            char buffer[256] = {0};
+            int valread = read(new_socket, buffer, sizeof(buffer));
+            if (valread < 0) {
+                perror("读取错误");
+            } else if (valread > 0) {
+                Student student = deserializeStudent(buffer);
+                cout << "收到学生数据: " << student.name << " " << student.number << " " << student.grade << " ";
+                for (int i = 0; i < 3; ++i) {
+                    cout << student.hobby[i] << " ";
+                }
+                cout << endl;
+                {
+                    lock_guard<mutex> lock(mtx);
+                    students.push_back(student);
+                    if (students.size() >= 1000) {
+                        saveFlag = true;
+                    }
+                }
+                cv.notify_one();
+            } else {
+                cerr << "接收到不完整的学生数据" << endl;
+            }
+            close(new_socket);
+        });
+    }
+
+    for (auto& thread : client_threads) {
+        thread.join();
+    }
     {
-        return 1;
+        lock_guard<mutex> lock(mtx);
+        done = true;
+    }
+    cv.notify_one();
+}
+void *agent(void *arg)
+{
+    AgentMesg *agentMesg = (AgentMesg *)arg;
+    eprosima::uxr::AgentInstance &agent_instance = agent_instance.getInstance();
+
+    if (!agent_instance.create(agentMesg->argcAgent, agentMesg->argvAgent))
+    {
+        printf("error");
+        return NULL;
     }
     agent_instance.run();
 
+    return NULL;
+}
+
+int main(int argc, char** argv) {
+    AgentMesg *agentMesg = new AgentMesg;
+    agentMesg->argcAgent = argc;
+    agentMesg->argvAgent = argv;
+
+    pthread_t tidAgent;
+    pthread_create(&tidAgent, NULL, agent, agentMesg);
+    pthread_detach(tidAgent);
+    // 启动文件保存线程
+    thread saverThread(fileSaver);
+
+
+    // 启动数据接收线程
+    thread receiverThread(receiveData);
+
+
+    receiverThread.join();
+    saverThread.join();
+
     return 0;
 }
diff --git a/src/cpp/middleware/fastdds/FastDDSMiddleware.cpp b/src/cpp/middleware/fastdds/FastDDSMiddleware.cpp
index a383fb9..a11a2b8 100644
--- a/src/cpp/middleware/fastdds/FastDDSMiddleware.cpp
+++ b/src/cpp/middleware/fastdds/FastDDSMiddleware.cpp
@@ -895,6 +895,7 @@ bool FastDDSMiddleware::write_data(
         uint16_t datawriter_id,
         const std::vector<uint8_t>& data)
 {
+    
    bool rv = false;
    auto it = datawriters_.find(datawriter_id);
    if (datawriters_.end() != it)
diff --git a/studentdata.c b/studentdata.c
new file mode 100644
index 0000000..eea77f1
--- /dev/null
+++ b/studentdata.c
@@ -0,0 +1,75 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file studentdata.c
+ * This source file contains the definition of the described types in the IDL file.
+ *
+ * This file was generated by the tool gen.
+ */
+
+#include "studentdata.h"
+
+#include <ucdr/microcdr.h>
+#include <string.h>
+
+bool Student_serialize_topic(ucdrBuffer* writer, const Student* topic)
+{
+    bool success = true;
+
+        success &= ucdr_serialize_string(writer, topic->name);
+
+        success &= ucdr_serialize_int32_t(writer, topic->number);
+
+        success &= ucdr_serialize_int32_t(writer, topic->grade);
+
+        for(size_t i = 0; i < sizeof(topic->hobby) / 255; ++i)
+        {
+            success &= ucdr_serialize_string(writer, topic->hobby[i]);
+        }
+    return success && !writer->error;
+}
+
+bool Student_deserialize_topic(ucdrBuffer* reader, Student* topic)
+{
+    bool success = true;
+
+        success &= ucdr_deserialize_string(reader, topic->name, 255);
+
+        success &= ucdr_deserialize_int32_t(reader, &topic->number);
+
+        success &= ucdr_deserialize_int32_t(reader, &topic->grade);
+
+        for(size_t i = 0; i < sizeof(topic->hobby) / 255; ++i)
+        {
+            success &= ucdr_deserialize_string(reader, topic->hobby[i], 255);
+        }
+    return success && !reader->error;
+}
+
+uint32_t Student_size_of_topic(const Student* topic, uint32_t size)
+{
+    uint32_t previousSize = size;
+        size += ucdr_alignment(size, 4) + 4 + (uint32_t)strlen(topic->name) + 1;
+
+        size += ucdr_alignment(size, 4) + 4;
+
+        size += ucdr_alignment(size, 4) + 4;
+
+        for(size_t i = 0; i < sizeof(topic->hobby) / 255; ++i)
+        {
+            size += ucdr_alignment(size, 4) + 4 + (uint32_t)strlen(topic->hobby[i]) + 1;
+        }
+    return size - previousSize;
+}
diff --git a/studentdata.h b/studentdata.h
new file mode 100644
index 0000000..a98a00c
--- /dev/null
+++ b/studentdata.h
@@ -0,0 +1,58 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file studentdata.h
+ * This header file contains the declaration of the described types in the IDL file.
+ *
+ * This file was generated by the tool gen.
+ */
+
+#ifndef _studentdata_H_
+#define _studentdata_H_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/*!
+ * @brief This struct represents the structure Student defined by the user in the IDL file.
+ * @ingroup studentdata
+ */
+typedef struct Student
+{
+    char name[255];
+
+    int32_t number;
+    int32_t grade;
+    char hobby[3][255];
+
+} Student;
+
+struct ucdrBuffer;
+
+bool Student_serialize_topic(struct ucdrBuffer* writer, const Student* topic);
+bool Student_deserialize_topic(struct ucdrBuffer* reader, Student* topic);
+uint32_t Student_size_of_topic(const Student* topic, uint32_t size);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _studentdata_H_
\ No newline at end of file
-- 
2.34.1

